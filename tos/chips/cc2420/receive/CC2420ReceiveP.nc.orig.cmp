  uint8_t m_missed_packets;
  norace uint8_t rxFrameLength;
  norace uint8_t m_bytes_left;
  cc2420_receive_state_t m_state;
  command error_t Init.init() {
    m_p_rx_buf = &m_rx_buf;
  }
  command error_t StdControl.start() {
      reset_state();
      m_state = S_STARTED;
      atomic receivingPacket = FALSE;
      call InterruptFIFOP.enableFallingEdge();
  }
  command error_t StdControl.stop() {
      m_state = S_STOPPED;
      reset_state();
      call CSN.set();
      call InterruptFIFOP.disable();
  }
  async event void InterruptFIFOP.fired() {
    if ( m_state == S_STARTED ) {
      m_state = S_RX_LENGTH;
      beginReceive();
    } else {
      m_missed_packets++;
    }
  }
  event void SpiResource.granted() {
    receive();
  }
  async event void RXFIFO.readDone( uint8_t* rx_buf, uint8_t rx_len,
                                    error_t error ) {
    cc2420_header_t* header = call CC2420PacketBody.getHeader( m_p_rx_buf );
    uint8_t tmpLen __DEPUTY_UNUSED__ = sizeof(message_t) - (offsetof(message_t, data) - sizeof(cc2420_header_t));
    uint8_t* COUNT(tmpLen) buf = TCAST(uint8_t* COUNT(tmpLen), header);
    rxFrameLength = buf[ 0 ];
    switch( m_state ) {
    case S_RX_LENGTH:
      m_state = S_RX_FCF;
      if ( rxFrameLength + 1 > m_bytes_left
           ) {
        flush();
      } else {
        if ( !call FIFO.get() && !call FIFOP.get() ) {
          m_bytes_left -= rxFrameLength + 1;
        }
        if(rxFrameLength <= MAC_PACKET_SIZE) {
          if(rxFrameLength > 0) {
            if(rxFrameLength > SACK_HEADER_LENGTH) {
              call RXFIFO.continueRead(buf + 1, SACK_HEADER_LENGTH);
            } else {
              m_state = S_RX_PAYLOAD;
              call RXFIFO.continueRead(buf + 1, rxFrameLength);
            }
          } else {
            atomic receivingPacket = FALSE;
            call CSN.set();
            call SpiResource.release();
            waitForNextPacket();
          }
        } else {
          flush();
        }
      }
      break;
    case S_RX_FCF:
      m_state = S_RX_PAYLOAD;
      if(call CC2420Config.isAutoAckEnabled() && !call 
        CC2420Config.isHwAutoAckDefault()) {
        if (((( header->fcf >> IEEE154_FCF_ACK_REQ ) & 0x01) == 1)
            && ((header->dest == call CC2420Config.getShortAddr())
                || (header->dest == AM_BROADCAST_ADDR))
            && ((( header->fcf >> IEEE154_FCF_FRAME_TYPE ) & 7) == IEEE154_TYPE_DATA)) {
          call CSN.set();
          call CSN.clr();
          call SACK.strobe();
          call CSN.set();
          call CSN.clr();
	  call RXFIFO.beginRead(buf + 1 + SACK_HEADER_LENGTH,
				rxFrameLength - SACK_HEADER_LENGTH);
          return;
        }
      }
      call RXFIFO.continueRead(buf + 1 + SACK_HEADER_LENGTH, rxFrameLength - 
                   SACK_HEADER_LENGTH);
      break;
    case S_RX_PAYLOAD:
      call CSN.set();
      if(!m_missed_packets) {
        call SpiResource.release();
      }
      if ( ( m_missed_packets && call FIFO.get() ) || !call FIFOP.get()
            || !m_timestamp_size
            || rxFrameLength <= 10) {
        call PacketTimeStamp.clear(m_p_rx_buf);
      }
      else {
          if (m_timestamp_size==1)
            call PacketTimeStamp.set(m_p_rx_buf, m_timestamp_queue[ m_timestamp_head ]);
          m_timestamp_head = ( m_timestamp_head + 1 ) % TIMESTAMP_QUEUE_SIZE;
          m_timestamp_size--;
          if (m_timestamp_size>0) {
            call PacketTimeStamp.clear(m_p_rx_buf);
            m_timestamp_head = 0;
            m_timestamp_size = 0;
          }
      }
      if ( ( buf[ rxFrameLength ] >> 7 ) && rx_buf ) {
        uint8_t type = ( header->fcf >> IEEE154_FCF_FRAME_TYPE ) & 7;
        signal CC2420Receive.receive( type, m_p_rx_buf );
        if ( type == IEEE154_TYPE_DATA ) {
          post receiveDone_task();
          return;
        }
      }
      waitForNextPacket();
      break;
    default:
      atomic receivingPacket = FALSE;
      call CSN.set();
      call SpiResource.release();
      break;
    }
  }
  task void receiveDone_task() {
    cc2420_metadata_t* metadata = call CC2420PacketBody.getMetadata( m_p_rx_buf );
    cc2420_header_t* header = call CC2420PacketBody.getHeader( m_p_rx_buf);
    uint8_t length = header->length;
    uint8_t tmpLen __DEPUTY_UNUSED__ = sizeof(message_t) - (offsetof(message_t, data) - sizeof(cc2420_header_t));
    uint8_t* COUNT(tmpLen) buf = TCAST(uint8_t* COUNT(tmpLen), header);
    metadata->crc = buf[ length ] >> 7;
    metadata->lqi = buf[ length ] & 0x7f;
    metadata->rssi = buf[ length - 1 ];
    if (passesAddressCheck(m_p_rx_buf) && length >= CC2420_SIZE) {
      m_p_rx_buf = signal Receive.receive( m_p_rx_buf, m_p_rx_buf->data,
					   length - CC2420_SIZE);
    }
    atomic receivingPacket = FALSE;
    waitForNextPacket();
  }
  void beginReceive() { m_state = S_RX_LENGTH;
    atomic receivingPacket = TRUE;
    if(call SpiResource.isOwner()) {
      receive();
    } else if (call SpiResource.immediateRequest() == SUCCESS) {
      receive();
    } else {
      call SpiResource.request();
    }
  }
  void flush() {
    reset_state();
    call CSN.set();
    call CSN.clr();
    call SFLUSHRX.strobe();
    call SFLUSHRX.strobe();
    call CSN.set();
    call SpiResource.release();
    waitForNextPacket();
  }
  void receive() {
    call CSN.clr();
    call RXFIFO.beginRead( (uint8_t*)(call CC2420PacketBody.getHeader( m_p_rx_buf )), 1 );
  }
  void waitForNextPacket() {
      if ( m_state == S_STOPPED ) {
        call SpiResource.release();
        return;
      }
      atomic receivingPacket = FALSE;
      if ( ( m_missed_packets && call FIFO.get() ) || !call FIFOP.get() ) {
        if ( m_missed_packets ) {
          m_missed_packets--;
        }
    beginReceive();
      } else {
        m_state = S_STARTED;
        m_missed_packets = 0;
        call SpiResource.release();
      }
  }
  void reset_state() {
    m_bytes_left = RXFIFO_SIZE;
    atomic receivingPacket = FALSE;
    m_timestamp_head = 0;
    m_timestamp_size = 0;
    m_missed_packets = 0;
  }
